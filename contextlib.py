'contextlib''在Python中,读写文件这样的资源要特别注意,必须在使用完毕后正确关闭它们.正确关闭文件资源的一个方法是使用 try...finally...'# try:#     f = open('/Users/aishangsaisai/Desktop/hellow.py','r')#     f.read()# finally:#     if f:#         f.close()'写try...finally...非常繁琐.Python的with语句允许我们非常方便的使用资源,而不必担心资源没有关闭,所以上面的代码可以简化为:'# with open('/Users/aishangsaisai/Desktop/hellow.py','r') as f:#     f.read()# class Query(object):#     def __init__(self,name):#         self.name = name#     def __enter__(self):#         print('Begin')#         return self#     def __exit__(self,exc_type,exc_value,traceback):#         if exc_type:#             print('Error')#         else:#             print('End')#     def query(self):#         print('Query info about %s...' % self.name)## with Query('Bob') as q:#     q.query()'@contextManager''编写 __enter__和__exit__仍然很繁琐,因此Python的标准库contextlib提供了更简单的写法,上面的代码可以改写如下↓'# from contextlib import contextmanager# class Query(object):#     def __init__(self,name):#         self.name = name##     def query(self):#         print('Query info about %s...' % self.name)## @contextmanager# def create_query(name):#     print('Begin')#     q = Query(name)#     yield q#     print('End')'@contextmanager 这个 decorator 接受一个 generator,用 yield 语句把 with...as var 把变量输出出去,然后,with 语句就可以正常工作了'# with create_query('Bob') as q:#     q.query()'@closing''如果一个对象没有实现上下文,我们就不能把它用于 with 语句.这个时候,可以用 closing() 来把该对象变为上下文对象''例如,用 with 语句使用 urlopen()'# from contextlib import closing# from urllib.request import urlopen## with closing(urlopen('https://github.com/CrazyDaiDai')) as page:#     print(page)#     for line in page:#         print(line)