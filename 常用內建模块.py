# 常用內建模块'datetime 是Python处理日期和时间的标准库''获取当前时间'from datetime import datetime# now = datetime.now()# print(now)# print(type(now))'获取指定日期和时间'# dt = datetime(2008,1,10,12,12) # 用指定的日期创建datetime# print(dt)'datetime 转换为 timestamp'# dt = datetime(2008,9,9,8,10)# print(dt.timestamp())  # 1220919000.0# timestamp 也可以直接被转换到UTC标准时区的时间# t = 1220919000.0# print(datetime.fromtimestamp(t)) # 本地时间# print(datetime.utcfromtimestamp(t))  # UTC时间'str 转换为 datetime'# sday = datetime.strptime('2008-9-9 8:10:30','%Y-%m-%d %H:%M:%S')# print(sday)'datetime 转换为 str'# now = datetime.now()# print(now.strftime('%a,%b %d %H:%M')) # Mon,Sep 18 19:41'conllections''namedtuple'from collections import namedtuple# # namedtuple('名称',[属性list])# point = namedtuple('Point',['x','y'])# p = point(50,100)# print(p.x,p.y)# print(isinstance(p,point),isinstance(p,tuple))# # 如果用坐标和半径表示一个圆,也可以用namedtuple定义# Circle = namedtuple('Circle',['x','y','r'])# c = Circle(50,100,30)# print(c.x,c.y,c.r)'deque'# 使用 list 存储数据时,按索引访问元素很快,但是插入和删除元素就很慢了,因为 list 是线性存储,数据量大的时候,插入和删除效率很低'deque 是为了高效实现插入和删除操作的双向列表,适合用于队列和栈'# from collections import deque# q = deque(['a','b','c'])# q.append('x')# q.appendleft('y')# print(q)# q.popleft()# print(q)'deque 除了实现 list 的 append() 和 pop() 外,还支持 appendleft() 和 popleft() 这样就可以非常高效地往头部添加或删除元素''defaultdict'# 使用 dict 时,如果引用的Key不存在,就会抛出KeyError.如果希望key不存在是,返回一个默认值,就用defaultdict:'除了在 Key 不存在时返回默认值,defaultdict 的其他行为跟 dict 是完全一样的'from collections import defaultdict# dd = defaultdict(lambda : 'N/A')# dd['key1'] = 'mac'# print(dd['key1'])# print(dd['key2'])'OrderedDict'# 使用dict时,key是无序的,在对dict做迭代时,我们无法确定key的顺序.如果要保持key的顺序,可以用'OrderedDict'# from collections import OrderedDict# d = dict([('a',1),('b',2),('c',3)])# print(d)# od = OrderedDict([('a',1),('b',2),('c',3)])# print(od)'注意 : OrderedDict 的Key是按照插入顺序排列的,而不是Key本身的排序'# from collections import OrderedDict# od = OrderedDict()# od['a'] = 1# od['c'] = 3# od['b'] = 2# print(od)# print(list(od.keys()))'OrderedDict 可以实现一个FIFO(先进先出)''Counter 是一个简单的计数器,例如,统计字符出现的个数'# from collections import Counter# c = Counter()# for ch in 'programming':# 	c[ch] = c[ch] + 1# print(c)# # Counter({'m': 2, 'r': 2, 'g': 2, 'n': 1, 'i': 1, 'o': 1, 'p': 1, 'a': 1})'Counter 实际上也是 dict 的一个子类''base64'# import base64# print(base64.b64encode(b'hi')) # b'aGk='# print(base64.b64decode(b'aGk=')) # b'hi'# # 由于标准的Base64编码后可能出现字符+和/,在URL中就不能直接作为参数# # 所以有一种'url safe'的base64编码,其实就是把字符+和/分别编程-和_# print(base64.b64encode(b'i\xb7\x1d\xfb\xef\xff')) # b'abcd++//'# print(base64.urlsafe_b64encode(b'i\xb7\x1d\xfb\xef\xff')) # b'abcd--__'# print(base64.urlsafe_b64decode(b'abcd--__'))'hashlib 提供了常见的摘要算法,MD5,SHA1等等'# import hashlib# md5 = hashlib.md5()# md5.update('how to use md5 in python hashlib?'.encode('utf-8'))# print(md5)# print(md5.hexdigest()) # d26a53750bc40b38b65a520292f69306# '如果数据量很大,可以分块多次调用 update(),最后计算的结果是一样的'# import hashlib# md5 = hashlib.md5()# md5.update('how to use md5'.encode('utf-8'))# md5.update(' in python hashlib?'.encode('utf-8'))# print(md5.hexdigest()) # d26a53750bc40b38b65a520292f69306'另一种常见的摘要算法是SHA1,调用SHA1和调用MD5类似'# import hashlib# sha1 = hashlib.sha1()# sha1.update('how to use md5'.encode('utf-8'))# sha1.update(' in python hashlib?'.encode('utf-8'))# print(sha1.hexdigest()) # b752d34ce353e2916e943dc92501021c8f6bca8cimport hashlibimport jsonimport osfrom collections import defaultdict# import sysdb = defaultdict(lambda :'None')# db['张三'] = '张三'# db['李四'] = 'lisi'md5_str = 'Crazy'name = input('注册输入昵称:')password = input('注册输入密码:')def get_md5(value):    md5 = hashlib.md5()    md5.update(value.encode('utf-8'))    return md5.hexdigest()def register(name,password):    hash_value = get_md5(name + password + md5_str)    db[name] = hash_valueregister(name,password)login_name = input('登录输入昵称:')login_password = input('登录输入密码:')def login(name,password):    if db[name] == 'None':        print('昵称- %s -不存在' % name)        return False    md5_value = get_md5(name + password + md5_str)    if (db[name] == md5_value):        print('🎉登录成功')        return True    else:        print('密码- %s -错误了' % password)        return Falselogin(login_name,login_password)